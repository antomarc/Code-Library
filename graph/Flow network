Maximum weighted closure of a graph:

所有由这个子图中的点出发的边都指向这个子图，那么这个子图为原图的一个closure（闭合子图）

每个节点向其所有依赖节点连边，容量inf
源点向所有正权值节点连边，容量为该权值
所有负权值节点向汇点连边，容量为该权值绝对值
以上均为有向边
最大权为sum{正权值}-{新图的最小割}
残量图中所有由源点可达的点即为所选子图



Eulerian circuit:
计入度和出度之差
无向边任意定向
出入度之差为奇数则无解
然后构图:
原图有向边不变，容量1 // 好像需要在新图中忽略有向边？
无向边按之前认定方向，容量1
源点向所有度数为正的点连边，容量abs(度数/2)
所有度数为负的点向汇点连边，容量abs(度数/2)
两侧均满流则有解
注意连通性的trick

终点到起点加一条有向边即可将path问题转为circuit问题



Feasible flow problem:
refer Feasible flow problem.cpp
由超级源点出发的边全部满流则有解
有源汇时，由汇点向源点连边，下界0上界inf即可转化为无源无汇上下界可行流

对于每条边<a->b cap{u,d}>，建边<ss->b cap(u)>、<a->st cap(u)>、<a->b cap(d-u)>

Maximum flow: //好像也可以二分
将可行流还原至原图后，在残量网络上继续完成最大流
Minimum flow: //好像也可以二分
建图时先不连汇点到源点的边，新图中完成最大流之后再连原汇至原源的边完成第二次最大流，此时t->s这条弧的流量即为最小流
判断可行流存在还是必须连原汇->原源的边之后查看满流
tips:
合并流量、减少边数来加速



Minimum cost feasible flow problem:
TODO
看起来像是在上面那样跑费用流就行了……



Minimum weighted vertex cover edge for bipartite graph:
for all vertex in X:
edge < s->x cap(weight(x)) >
for all vertex in Y:
edge < y->t cap(weight(y)) >
for original edges
edge < x->y cap(inf) >

ans={maximum flow}={minimum cut}
残量网络中的所有简单割( (源点可达 && 汇点不可达) || (源点不可达 && 汇点可达) )对应着解



Maximum weighted vertex independent set for bipartite graph:
ans=Sum{点权}-value{Minimum weighted vertex cover edge}
解应该就是最小覆盖集的补图吧……



方格取数:
取方格获得收益
当取了相邻方格时付出边的代价

必取的方格到源/汇的边的容量inf
相邻方格之间的边的容量为代价
ans=sum{方格收益}-{最大流}



Tips:
两点间可以不止有一种边，也可以不止有一条边，无论有向无向;
两点间容量inf则可以设法化简为一个点;
点权始终要转化为边权;
不参与决策的边权设为inf来排除掉;
