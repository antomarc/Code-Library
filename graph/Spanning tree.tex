\subsection{Spanning Tree}
\begin{itemize}
\item Minimum Bottleneck Spanning Tree\\
Kruscal

\item All-pairs vertexes' Minimum Bottleneck Path\\
DP in the Kruscal's MST\\
O($n^2$)*O(1)

\item Minimum Diameter Spanning Tree\\
Kariv-Hakimi Algorithm

\item Directed MST\\
Chuâ€“Liu/Edmonds' Algorithm

\item Second-best MST\\
get All-pairs vertexes' Minimum Bottleneck Path, then enumerate all no-tree-edges to replace the longest edge between two vertexes to get a worse MST

\item Degree-constrained MST
\begin{enumerate}
\item remove the vertex from the whole graph,then add edges to increase degrees and connect different connected components together ( O(mlogm + n) with kruscal )
\item if we can't connect all connected components together, there exists no any spanning tree
\item next step is add edges to root vertex greedily, increase degrees, and decrease our answer ( O(k*n) )
\item need all vertexes' minimum bottleneck path to root vertex
\end{enumerate}

\item Minimum Ratio Spanning Tree\\
Binary search

\item Manhattan MST\\
combining line sweep with divide-and-conquer algorithm

\item Minimum Steiner Tree\\
the MST contain all k vertexes
\begin{enumerate}
\item bit-mask with dijkstra O($2^k\times\{dijkstra\}$)
\item then run a bit-mask DP( O(n*($2^k$)) )
\end{enumerate}

\item Count Spanning Trees\\
Kirchhoff's theorem\\
simply calculate the minor of (degree Matrix - edge Matrix)

\item k-best MST\\
do like second-best MST for k times
\end{itemize}
