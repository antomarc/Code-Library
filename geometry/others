`eps`

`如果sqrt(a), asin(a), acos(a) 中的a是你自己算出来并传进来的，那就得小心了。如果a本来应该是0的，由于浮点误差，可能实际是一个绝对值很小的负数（比如$-1^{-12}$），这样sqrt(a)应得0的，直接因a不在定义域而出错。类似地，如果a本来应该是$\pm$1,则asin(a)、acos(a)也有可能出错。因此，对于此种函数，必需事先对a进行校正。`

`现在考虑一种情况，题目要求输出保留两位小数。有个case的正确答案的精确值是0.005,按理应该输出0.01，但你的结果可能是0.005000000001(恭喜)，也有可能是0.004999999999(悲剧)，如果按照printf("\%.2lf", a)输出，那你的遭遇将和括号里的字相同。`
`如果a为正，则输出a + eps, 否则输出a - eps。`

`不要输出-0.000`

`注意double的数据范围`

a==b  fabs(a-b)<eps
a!=b  fabs(a-b)>eps
a<b   a+eps<b
a<=b  a<b+eps
a>b   a>b+eps
a>=b  a+eps>b

`三角函数`

cos/sin/tan 输入弧度
`acos 输入[-1,+1]，输出[0,$\pi$]`
`asin 输入[-1,+1]，输出$[-\frac{\pi}{2},+\frac{\pi}{2}]$`
`atan 输出$[-\frac{\pi}{2},+\frac{\pi}{2}]$`
`atan2 输入(y,x)(注意顺序),返回$\tan(\frac{y}{x}) \in [-\pi,+\pi]$。xy都是零的时候会发生除零错误`

other

log          `自然对数(ln)`
exp          pow(e,x)
log10        `你猜……`
ceil         smallest interger >= x (watch out x<0
floor        greatest interger <= x (watch out x<0
trunc        向零 (if x>0, trunc is likes floor. else trunc is likes ceil)
nearbyint    Rounds x to an integral value, using the rounding direction specified by fegetround.
round        Returns the integral value that is nearest to x, with halfway cases rounded away from zero.

round

cpp:  四舍六入五留双
java: add 0.5,then floor
cpp:
`（一）当尾数小于或等于4时，直接将尾数舍去。`
`（二）当尾数大于或等于6时，将尾数舍去并向前一位进位。`
`（三）当尾数为5，而尾数后面的数字均为0时，应看尾数“5”的前一位：若前一位数字此时为奇数，就应向前进一位；若前一位数字此时为偶数，则应将尾数舍去。数字“0”在此时应被视为偶数。`
`（四）当尾数为5，而尾数“5”的后面还有任何不是0的数字时，无论前一位在此时为奇数还是偶数，也无论“5”后面不为0的数字在哪一位上，都应向前进一位。`

rotate mat:
`$\begin{matrix}
\cos(\theta) & -\sin(\theta) \\
\sin(\theta) & \cos(\theta)
\end{matrix}$`
